<!DOCTYPE html>
<html lang="en">
	<head>
		<!-- COMMON TAGS -->
		<meta charset="utf-8">
		<title>ⒹⒹⒹ an event by Bakken & Bæck</title>
		<!-- Search Engine -->
		<meta name="description" content="ⒹⒹⒹ is a quarterly event by Bakken & Bæck, in which we invite one developer, one designer and one thinker to reflect on a specific theme. For the first edition, we’ll focus on the theme of “Belonging”.">
		<meta name="image" content="https://bakkenbaeck.com/images/ddd-share.png">
		<!-- Schema.org for Google -->
		<meta itemprop="name" content="ⒹⒹⒹ an event by Bakken & Bæck">
		<meta itemprop="description" content="ⒹⒹⒹ is a quarterly event by Bakken & Bæck, in which we invite one developer, one designer and one thinker to reflect on a specific theme. For the first edition, we’ll focus on the theme of “Belonging”.">
		<meta itemprop="image" content="https://bakkenbaeck.com/images/ddd-share.png">
		<!-- Twitter -->
		<meta name="twitter:card" content="summary">
		<meta name="twitter:title" content="ⒹⒹⒹ an event by Bakken & Bæck">
		<meta name="twitter:description" content="ⒹⒹⒹ is a quarterly event by Bakken & Bæck, in which we invite one developer, one designer and one thinker to reflect on a specific theme. For the first edition, we’ll focus on the theme of “Belonging”.">
		<meta name="twitter:site" content="@bakkenbaeck">
		<meta name="twitter:creator" content="@bakkenbaeck">
		<meta name="twitter:image:src" content="https://bakkenbaeck.com/images/ddd-share.png">
		<!-- Open Graph general (Facebook, Pinterest & Google+) -->
		<meta name="og:title" content="ⒹⒹⒹ an event by Bakken & Bæck">
		<meta name="og:description" content="ⒹⒹⒹ is a quarterly event by Bakken & Bæck, in which we invite one developer, one designer and one thinker to reflect on a specific theme. For the first edition, we’ll focus on the theme of “Belonging”.">
		<meta name="og:image" content="https://bakkenbaeck.com/images/ddd-share.png">
		<meta name="og:url" content="https://bakkenbaeck.com/ddd">
		<meta name="og:site_name" content="ⒹⒹⒹ an event by Bakken & Bæck">
		<meta name="og:type" content="website">

		<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
		<link rel="icon" href="/favicon.ico" type="image/x-icon">

		<style>
			body {
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
				font-family: sans-serif;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>
		<canvas id="layer1"></canvas>
		<canvas id="layer2"></canvas>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/104/three.min.js"></script>
		<script id="vertexShader" type="x-shader/x-vertex">
			void main() {
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec2 u_resolution;
			uniform sampler2D u_texture_1;
			uniform sampler2D u_texture_2;
			uniform sampler2D u_texture_3;
			uniform sampler2D u_texture_4;
			uniform float u_loop_1;
			uniform float u_loop_2;
			uniform bool u_loop_1_running;
			uniform bool u_loop_2_running;
			uniform vec2 st;

			void main() {
				float amplitude = 100.;
				float frequency = 5.0;

				vec2 st = gl_FragCoord.st/u_resolution.xy;
				vec3 pattern_1 = vec3(0.6);
				vec3 pattern_2 = vec3(0.6);
				vec3 rothko_1 = vec3(0.6);
				vec3 rothko_2	 = vec3(0.6);

				vec4 texture_1 = texture2D(u_texture_1, st);
				vec4 texture_2 = texture2D(u_texture_2, st);
				vec4 texture_3 = texture2D(u_texture_3, st);
				vec4 texture_4 = texture2D(u_texture_4, st);

				pattern_1 += texture_1.xyz;
				pattern_2 += texture_2.xyz;
				rothko_1 += texture_3.xyz;
				rothko_2 += texture_4.xyz;

				vec3 print = vec3(0.6);
				vec3 layer_1 = abs(pattern_1 - rothko_1);
				vec3 layer_2 = abs(pattern_2 - rothko_2);
				vec3 layer_3 = abs(pattern_1 - rothko_1);

				if(u_loop_1_running) {
					if( all(greaterThan(layer_1, vec3(u_loop_1)))) {
						layer_1 = vec3(0.08);
					} else if( all(lessThan(layer_2, vec3(u_loop_1)))) {
						layer_2 = vec3(0.08);
						layer_1 = layer_2;
					} else {
						layer_1 = vec3(0.6);
					}
				}

				if(u_loop_2_running) {
					if( all(greaterThan(layer_1, vec3(u_loop_2)))) {
						layer_1 = vec3(0.08);
					} else if( all(lessThan(layer_2, vec3(u_loop_2)))) {
						layer_2 = vec3(0.08);
						layer_1 = layer_2;
					} else {
						layer_1 = vec3(0.6);
					}
				}

				vec4 texture = vec4(layer_1, 1.0);

				gl_FragColor = texture;
			}
		</script>
    <script>
				let container;
				let canvas;
        let camera, scene, renderer;
				let uniforms;
				let loop_1 = 0.0;
				let loop_2 = 0.0;
				let loop_1_running = true;
				let loop_2_running = false;

				const layer1 = new Image();
				const layer2 = new Image();

        init();
				animate();

        function init() {
					renderer = new THREE.WebGLRenderer();
					renderer.setClearColor(1.0, 1.0, 1.0, 0.0);
					renderer.setPixelRatio( window.devicePixelRatio );

					container = document.getElementById( 'container' );
					container.appendChild( renderer.domElement );

          camera = new THREE.Camera();
          camera.position.z = 1;

					scene = new THREE.Scene();

					const geometry = new THREE.PlaneBufferGeometry( 2, 2 );

					const ctx_1 = document.querySelector('#layer1').getContext('2d');
					const ctx_2 = document.querySelector('#layer2').getContext('2d');
					const canvas_1 = ctx_1.canvas;
					const canvas_2 = ctx_2.canvas;
					canvas_1.width = window.innerWidth;
					canvas_1.height = window.innerHeight;
					canvas_2.width = window.innerWidth;
					canvas_2.height = window.innerHeight;

					function isPortrait() {
						const ratio = window.innerWidth / window.innerHeight;
						return ratio >= 1 ? false : true;
					}

					function setSource() {
						ctx_1.clearRect(0, 0, canvas_1.width, canvas_1.height);
						ctx_2.clearRect(0, 0, canvas_2.width, canvas_2.height);

						layer1.src = isPortrait() ? "img/intro_p.svg" : "img/intro.svg";
						layer2.src = "img/quote.svg";
					}
					setSource();

					console.log(layer1, layer2)

					function updateCanvas() {
						setSource();
						canvasTexture_1.needsUpdate = true;
						canvasTexture_2.needsUpdate = true;
					}

					function scaleToFit(img, context){
						const canvas = context.canvas;
						const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
						const x = (canvas.width / 2) - (img.width / 2) * scale;
						const y = (canvas.height / 2) - (img.height / 2) * scale;
						return context.drawImage(img, x, y, img.width * scale, img.height * scale);
					}

					function drawImage(img, context, texture) {
						context.fillRect(0, 0, context.canvas.width, context.canvas.height);
						scaleToFit(img, context);
						texture.needsUpdate = true;
					}

					layer1.onload = () => drawImage(layer1, ctx_1, canvasTexture_1);
					layer2.onload = () => drawImage(layer2, ctx_2, canvasTexture_2);

					window.addEventListener('resize', updateCanvas, false);

					const canvasTexture_1 = new THREE.CanvasTexture(ctx_1.canvas);
					const canvasTexture_2 = new THREE.CanvasTexture(ctx_2.canvas);

					const loader = new THREE.TextureLoader()

					const texture1 = canvasTexture_1;
					const texture2 = canvasTexture_2;
					const texture3 = loader.load( './img/rothko_s.jpg' );
					const texture4 = loader.load( './img/rothko3.jpg' );

          uniforms = {
						u_loop_1: { type: "f", value: 1.0 },
						u_loop_2: { type: "f", value: 1.0 },
						u_loop_1_running: { type: "b", value: false },
						u_loop_2_running: { type: "b", value: false },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						u_texture_1: { type: "t", value: texture1 },
						u_texture_2: { type: "t", value: texture2 },
						u_texture_3: { type: "t", value: texture3 },
						u_texture_4: { type: "t", value: texture4 },
					};

          const material = new THREE.ShaderMaterial({
						uniforms: uniforms,
						vertexShader: document.getElementById( 'vertexShader' ).textContent,
						fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
						transparent: true,
						opacity: 0,
					});

					const mesh = new THREE.Mesh(geometry, material);

					scene.add(mesh);

				  onWindowResize();
					window.addEventListener('resize', onWindowResize, false);
				}

        function onWindowResize(event) {
					renderer.setSize(window.innerWidth, window.innerHeight);
					camera.aspect = renderer.domElement.width / renderer.domElement.width;
					uniforms.u_resolution.value.x = renderer.domElement.width;
					uniforms.u_resolution.value.y = renderer.domElement.height;
					console.log('resize')
        }

        function animate() {
					requestAnimationFrame(animate);
					render();
				}

        function render() {
					loop_1_running && (loop_1 += 0.01);
					loop_2_running && (loop_2 += 0.01);

					const shortVelocity = .08;

					loop_1_curve = Math.sin(loop_1 * shortVelocity);
					loop_2_curve = Math.sin(loop_2 * shortVelocity);

					if (loop_1_running) {
						if ( loop_1_curve > 0.99) {
							loop_1 = 0;
							loop_1_running = false;
							loop_2_running = true;
						}
					}

					if (loop_2_running) {
						if ( loop_2_curve > 0.99) {
							loop_2 = 0;
							loop_2_running = false;
							loop_1_running = true;
						}
					}

					shortLoop_1 = Math.abs(loop_1_curve, 0);
					shortLoop_2 = Math.abs(loop_2_curve, 0);

					uniforms.u_loop_1.value = shortLoop_1; // adjusts loop speed
					uniforms.u_loop_2.value = shortLoop_2; // adjusts loop speed
					uniforms.u_loop_1_running.value = loop_1_running;
					uniforms.u_loop_2_running.value = loop_2_running;

					renderer.render( scene, camera );
        }
		</script>
	</body>
</html>
