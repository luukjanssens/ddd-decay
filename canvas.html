<!DOCTYPE html>
<html lang="en">
	<head>
		<title>flocsdsking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
				font-family: sans-serif;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #000;
				position: absolute;
				top: 10px;
				width: 100%;
			}

			#container {
				position: relative;
				z-index: 10;
				background: red;
				opacity: 1;
			}

			.text {
				z-index: 0;
				font-size: 2em;
				color: black;
				position: absolute;
				opacity: 1;
				right: 20vw;
				top: 15vw;
				max-width: 400px;
			}
		</style>
	</head>
	<body>

		<div id="container"></div>

		<script src="js/three.min.js"></script>
		<script id="vertexShader" type="x-shader/x-vertex">
			void main() {
				gl_Position = vec4( position, 1.0 );
			}
		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			uniform vec2 u_resolution;
			uniform vec2 u_textres;
			uniform float u_time;
			uniform sampler2D u_texture_1;
			uniform sampler2D u_texture_2;
			uniform sampler2D u_texture_3;
			uniform sampler2D u_texture_4;
			uniform float u_days;
			uniform float u_shortLoop_1;
			uniform bool u_shortLoop_1_running;
			uniform float u_shortLoop_2;
			uniform bool u_shortLoop_2_running;
			uniform float u_longLoop;
			uniform vec2 st;
			uniform vec2 st2;
			uniform vec2 u_fragcoord;

			void main() {
				vec2 st = gl_FragCoord.st/u_resolution.xy;
				vec2 st2 = gl_FragCoord.st/u_textres.xy;
				vec3 text_1;
				vec3 text_2;
				vec4 texture_1 = texture2D(u_texture_1, st);
				vec4 texture_2 = texture2D(u_texture_2, st);

				text_1 += texture_1.xyz;
				text_2 += texture_2.xyz;

				gl_FragColor = vec4(text_1 * text_2, 1.0);
			}
		</script>

    <script>
				let container;
				let canvas;
        let camera, scene, renderer;
				let uniforms;
				const img = new Image();
				let textSize = new THREE.Vector2();
				let days = 1.0;
				let shortLoop_1 = 0.0;
				let shortLoop_2 = 0.0;

				let clock_1 = new THREE.Clock();
				let clock_2 = new THREE.Clock();
				clock_2.autoStart = false;
				let date = Date.now();

        init();
				animate();


        function init() {
					renderer = new THREE.WebGLRenderer();
					renderer.setClearColor(1.0, 1.0, 1.0, 0.0);
					renderer.setPixelRatio( window.devicePixelRatio );

					container = document.getElementById( 'container' );
					container.appendChild( renderer.domElement );

          camera = new THREE.Camera();
			//    camera.position.z = 1;
			//		camera.updateProjectionMatrix();
			//		camera.aspect = window.innerWidth / window.innerHeight;
			//		renderer.setSize( window.innerWidth, window.innerHeight);

					scene = new THREE.Scene();

					const geometry = new THREE.PlaneBufferGeometry( 2, 2 );


					const ctx = document.createElement('canvas').getContext('2d');
					const canvas = ctx.canvas;
					canvas.id = 'newcanvas';
					console.log(canvas)
					canvas.width = window.innerWidth;
					canvas.height = window.innerHeight;
					console.log('ONE', img.width, img.height, canvas.width, window.innerWidth, canvas.height, window.innerHeight)

					function updateCanvas() {
						canvas.width = img.width;
						canvas.height = img.height;
					}

					function scaleToFit(img){
						const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
						const x = (canvas.width / 2) - (img.width / 2) * scale;
						const y = (canvas.height / 2) - (img.height / 2) * scale;
						ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
					}

					img.onload = () => {
						ctx.fillRect(0, 0, canvas.width, canvas.height);
						scaleToFit(img)
						canvasTexture.needsUpdate = true;
						console.log('TWO', img.width, img.height, canvas.width, window.innerWidth, canvas.height, window.innerHeight)
					}

					window.addEventListener('resize', updateCanvas, false);

					img.src = "img/text.svg";

					const canvasTexture = new THREE.CanvasTexture(ctx.canvas);
					canvasTexture.needsUpdate = true;
					const loader = new THREE.TextureLoader();


					const texture1 = loader.load( './img/test-9.jpg' );
					const texture2 = loader.load( './img/rothko.jpg' );
					const text1 = loader.load( './img/text_v2.jpg' );
					const text2 = canvasTexture;

          uniforms = {
						u_shortLoop_1: { type: "f", value: 1.0 },
						u_shortLoop_1_running: { type: "b", value: false },
						u_shortLoop_2: {value: 1.0 },
						u_shortLoop_2_running: {value: false },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						u_textres: { type: "v2", value: new THREE.Vector2() },
						u_texture_1: { type: "t", value: texture1 },
						u_texture_2: { type: "t", value: text2 },
						u_fragcoord: { type: "v2", value: new THREE.Vector2() }
					};

			//		const material = new THREE.MeshBasicMaterial({
			//			map: canvasTexture,
					//	map: texture2,
			//		});

          const material = new THREE.ShaderMaterial({
						uniforms: uniforms,
						vertexShader: document.getElementById( 'vertexShader' ).textContent,
						fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
						transparent: true,
						opacity: 0,
					});


					const location = material.uniforms;
					console.log(location)

					const mesh = new THREE.Mesh(geometry, material);

					scene.add(mesh);


					//var title=document.querySelector('canvas');
					//var bounds=title.getBoundingClientRect();
					//var location = THREE.getUniformLocation(material,"contentPosition");
					//var location = material.getUniforms();
					//THREE.uniform2f(location,bounds.left,bounds.top);
					//var location=THREE.getUniformLocation(material,"contentSize");
					//THREE.uniform2f(location,bounds.width,bounds.height);

				  onWindowResize();
					window.addEventListener('resize', onWindowResize, false);
				}

        function onWindowResize(event) {
					renderer.setSize(window.innerWidth, window.innerHeight);
					uniforms.u_resolution.value.x = renderer.domElement.width;
					uniforms.u_resolution.value.y = renderer.domElement.height;
					uniforms.u_textres.value.x = img.width;
					uniforms.u_textres.value.y = img.height;
        }

        function animate() {
					requestAnimationFrame(animate);
					render();
				}

        function render() {
					// uniforms.u_time.value += 0.05;
					days += (0 - days)*0.05;

					const shortVelocity = 0.09;
					const shortLoopTime_1 = clock_1.getElapsedTime();
					const shortLoopTime_2 = clock_2.getElapsedTime();

					shortLoop_1_curve = Math.sin(shortLoopTime_1 * shortVelocity);
					shortLoop_2_curve = Math.sin(shortLoopTime_2 * shortVelocity);

					shortLoop_1 = Math.abs(shortLoop_1_curve, 0);
					shortLoop_2 = Math.abs(shortLoop_2_curve, 0);

					if(clock_1.running && shortLoop_1 > 0.99) {
						clock_1.stop();
						clock_2.start();
						console.log('start 2')
					}
					if(clock_2.running && shortLoop_2 > 0.99) {
						clock_2.stop();
						clock_1.start();
						console.log('start 1')
					}

					uniforms.u_shortLoop_1.value = shortLoop_1 * 0.85; // adjusts loop speed
					uniforms.u_shortLoop_2.value = shortLoop_2 * 0.85; // adjusts loop speed
					uniforms.u_shortLoop_1_running.value = clock_1.running;
					uniforms.u_shortLoop_2_running.value = clock_2.running;

					uniforms.u_textres.value.x = img.width;
					uniforms.u_textres.value.y = img.height;

					renderer.render( scene, camera );
        }
    </script>
	</body>
</html>
