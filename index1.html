<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - gpgpu - flocking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
				font-family: Monospace;
				font-size:13px;
				text-align:center;
				text-align:center;
			}

			a {
				color:#0078ff;
			}

			#info {
				color: #000;
				position: absolute;
				top: 10px;
				width: 100%;
			}

			#container {
				max-width: 90%;
			}


		</style>
	</head>
	<body>
		<script src="https://threejs.org/build/three.js"></script>
		<script src="https://threejs.org/examples/js/libs/stats.min.js"></script>
		<script src="https://threejs.org/examples/js/libs/dat.gui.min.js"></script>
		<script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>

		<div class="wrapper">
			<div id="container"></div>
		</div>
		<script id="vertexShader" type="x-shader/x-vertex">
			attribute vec2 uv;
			attribute vec2 position;
			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = vec4(position, 0.0, 1.0);
			}
		</script>
		<!-- This is the fragment shader -->
    <script id="fragmentShader" type="x-shader/x-fragment">
			// Here I am passing uniforms, the formality for this is to use u_
			// Uniforms will be the way of communication between three and out shader

			// flow
			precision highp float;
			precision highp int;
			uniform sampler2D tWater;
			uniform sampler2D tFlow;
			uniform float uTime;
			varying vec2 vUv;
			uniform vec4 res;
			//

			uniform vec2 u_resolution;
			uniform float u_time;
			uniform sampler2D u_texture_1;
			uniform sampler2D u_texture_2;
			uniform sampler2D u_texture_3;
			uniform float u_days;
			uniform vec2 u_mouse;

			void main() {

				// R and G values are velocity in the x and y direction
				// B value is the velocity length
				vec3 flow = texture2D(u_texture_1, vUv).rgb;

				vec2 uv = .5 * gl_FragCoord.xy / res.xy ;
				vec2 myUV = (uv - vec2(0.5))*res.zw + vec2(0.5);
				myUV -= flow.xy * (0.15 * 0.7);

				vec3 tex = texture2D(u_texture_2, myUV).rgb;

				gl_FragColor = vec4(tex.r, tex.g, tex.b, 1.0);
			}
		</script>

    <script>
				var container;
				var canvas;
				var gl;
        var camera, scene, renderer;
        var uniforms;
				var days = 1;
				var mouse = new THREE.Vector2();


        init();
        animate();


				function onMouseMove( event ) {
					// calculate mouse position in normalized device coordinates
					// (-1 to +1) for both components

					mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
					mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				}

        function init() {
					renderer = new THREE.WebGLRenderer();
					renderer.setPixelRatio( window.devicePixelRatio );

					container = document.getElementById( 'container' );

					container.appendChild( renderer.domElement );

          camera = new THREE.Camera();
          camera.position.z = 1;

					scene = new THREE.Scene();
					scene.background = new THREE.Color( 0xfff000 );
					 //scene.background = new THREE.Color( 0xfff000 );


          var geometry = new THREE.PlaneBufferGeometry( 2, 2 );

					var loader = new THREE.TextureLoader()

					const rothko = loader.load( './bb1.jpg' );
					const text = loader.load( './textnoise.jpg' );
					const rothko3 = loader.load( './bb2.jpg' );

          uniforms = {
						u_time: { type: "f", value: 1.0 },
						u_days: { type: "f", value: 1.0 },
						u_resolution: { type: "v2", value: new THREE.Vector2() },
						u_mouse: { type: "v2", value: new THREE.Vector2() },
						u_texture_1: { type: "t", value: rothko },
						u_texture_2: { type: "t", value: text },
						u_texture_3: { type: "t", value: rothko3 }
					};

          var material = new THREE.ShaderMaterial( {
              uniforms: uniforms,
              // vertexShader: document.getElementById( 'vertexShader' ).textContent,
							fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
							transparent: true,
							opacity: 0
					} );

          var mesh = new THREE.Mesh( geometry, material );

					scene.add( mesh );

					document.onmousemove = function(e){
						uniforms.u_mouse.value.x = e.pageX
						uniforms.u_mouse.value.y = e.pageY
					}

					onWindowResize();
					window.addEventListener( 'resize', onWindowResize, false );
        }

        function onWindowResize( event ) {
            renderer.setSize( window.innerWidth, window.innerHeight );
            uniforms.u_resolution.value.x = renderer.domElement.width;
            uniforms.u_resolution.value.y = renderer.domElement.height;
        }

        function animate() {
            requestAnimationFrame( animate );
            render();
        }

        function render() {
           // uniforms.u_time.value += 0.05;

						days += (0 - days)*0.01;
						uniforms.u_days.value = days;

            renderer.render( scene, camera );
        }
    </script>
	</body>
</html>
